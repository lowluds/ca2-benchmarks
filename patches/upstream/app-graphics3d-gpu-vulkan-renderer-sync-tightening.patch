diff --git a/gpu_vulkan/renderer.cpp b/gpu_vulkan/renderer.cpp
index 88ec2e9..4cf3dd7 100644
--- a/gpu_vulkan/renderer.cpp
+++ b/gpu_vulkan/renderer.cpp
@@ -1248,8 +1248,9 @@ namespace gpu_vulkan
 
       }
 
-      // Make sure you wait for GPU rendering to finish
-      vkDeviceWaitIdle(m_pcontext->logicalDevice()); // Or wait on a specific fence
+      // NOTE: Scope synchronization to the graphics queue used for readback work.
+      ::cast < ::gpu_vulkan::queue > pqueueGraphics = m_pcontext->m_pgpudevice->graphics_queue();
+      vkQueueWaitIdle(pqueueGraphics->m_vkqueue);
 
 
       //auto pimpact = m_pgpucontext->m_pimpact;
@@ -1365,11 +1366,6 @@ namespace gpu_vulkan
 
    void renderer::sample()
    {
-
-      ::cast < ::gpu_vulkan::queue > pqueueGraphics = m_pgpucontext->m_pgpudevice->graphics_queue();
-
-      vkQueueWaitIdle(pqueueGraphics->m_vkqueue);
-
       //auto callback = m_callbackImage32CpuBuffer;
 
   //      if (callback)
@@ -2403,10 +2399,7 @@ namespace gpu_vulkan
       m_pshaderImageBlend->unbind(pcommandbuffer);
 
       //vkCmdEndRenderPass(...);
-
-      ::cast < ::gpu_vulkan::queue > pqueueGraphics = m_pgpucontext->m_pgpudevice->graphics_queue();
-
-      vkQueueWaitIdle(pqueueGraphics->m_vkqueue);
+      // NOTE: Avoid queue-wide stalls in the draw path; frame submission sync handles ordering.
 
       //vkFreeCommandBuffers(m_pgpucontext->logicalDevice(), m_pgpucontext->m_vkcommandpool, 1, &pcommandbuffer->m_vkcommandbuffer);
 
@@ -2932,10 +2925,7 @@ namespace gpu_vulkan
       pshader->unbind(pcommandbuffer);
 
       //vkCmdEndRenderPass(...);
-
-      ::cast < ::gpu_vulkan::queue > pqueueGraphics = m_pgpucontext->m_pgpudevice->graphics_queue();
-
-      vkQueueWaitIdle(pqueueGraphics->m_vkqueue);
+      // NOTE: Avoid queue-wide stalls in the draw path; frame submission sync handles ordering.
 
       //vkFreeCommandBuffers(m_pgpucontext->logicalDevice(), m_pgpucontext->m_vkcommandpool, 1, &pcommandbuffer->m_vkcommandbuffer);
 
@@ -3263,10 +3253,7 @@ namespace gpu_vulkan
       pshader->unbind(pcommandbuffer);
 
       //vkCmdEndRenderPass(...);
-
-      ::cast < ::gpu_vulkan::queue > pqueueGraphics = m_pgpucontext->m_pgpudevice->graphics_queue();
-
-      vkQueueWaitIdle(pqueueGraphics->m_vkqueue);
+      // NOTE: Avoid queue-wide stalls in the draw path; frame submission sync handles ordering.
 
       //vkFreeCommandBuffers(m_pgpucontext->logicalDevice(), m_pgpucontext->m_vkcommandpool, 1, &pcommandbuffer->m_vkcommandbuffer);
 

